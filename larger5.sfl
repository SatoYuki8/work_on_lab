/* A<5> > B<5> => 1 */

declare larger5{
    input a<5>, b<5>;
    output l;
/*    output s;*/
    output eq;
    instrin do;

    instr_arg do(a, b);
}


module larger5{
    input a<5>, b<5>;
    output l;
    output eq;
    instrin do;

    sel_v l_tmp<5>;
    sel_v eq_tmp<5>;

    comp comp1, comp2, comp3, comp4, comp5;

    instruct do par{
	    l_tmp<4> = (comp1.do(l_tmp<4>, eq_tmp<4>).l);
	    l_tmp<3> = (comp2.do(l_tmp<3>, eq_tmp<3>).l);
	    l_tmp<2> = (comp3.do(l_tmp<2>, eq_tmp<2>).l);
	    l_tmp<1> = (comp4.do(l_tmp<1>, eq_tmp<1>).l);
	    l_tmp<0> = (comp5.do(l_tmp<0>, eq_tmp<0>).l);
	    eq_tmp<4> = (comp1.do(l_tmp<4>, eq_tmp<4>).eq);
	    eq_tmp<3> = (comp2.do(l_tmp<3>, eq_tmp<3>).eq);
	    eq_tmp<2> = (comp3.do(l_tmp<2>, eq_tmp<2>).eq);
	    eq_tmp<1> = (comp4.do(l_tmp<1>, eq_tmp<1>).eq);
	    eq_tmp<0> = (comp5.do(l_tmp<0>, eq_tmp<0>).eq);	    

	alt{
	    l_tmp<4>: l = 0b1;
	    l_tmp<3>: any{(eq_tmp<4>):l = 0b1};
	    l_tmp<2>: l = 0b1;
	    l_tmp<1>: l = 0b1;
	    l_tmp<0>: l = 0b1;	    
	}

	alt{
	    (comp1.do(l_tmp<4>, eq_tmp<4>).eq): eq = 0b1;
	    (comp2.do(l_tmp<3>, eq_tmp<3>).eq): eq = 0b1;
	    (comp3.do(l_tmp<2>, eq_tmp<2>).eq): eq = 0b1;
	    (comp4.do(l_tmp<1>, eq_tmp<1>).eq): eq = 0b1;
	    (comp5.do(l_tmp<0>, eq_tmp<0>).eq): eq = 0b1;	    
	}
    }
}
